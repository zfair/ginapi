package main

import (
	"bytes"
	"errors"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"text/template"
)

const (
	CodegenModeServer = "server"
	CodegenModeClient = "client"

	serviceFileTmpl = `// Generated by ginapi. DO NOT EDIT.
package ginapi
{{range .Services}}
type {{.Name}} interface {
}
{{end}}
`
)

var (
	CodegenModes = map[string]struct{}{
		CodegenModeServer: {},
		CodegenModeClient: {},
	}

	ErrCodegenInpathNotExists = errors.New("input path not exists")
	ErrCodegenInpathNotDir    = errors.New("input path not a directory")
)

type Codegen struct {
	*Parser

	outpath string
	mode    string
}

func NewCodegen() *Codegen {
	return &Codegen{
		Parser: NewParser(),
	}
}

func (c *Codegen) MkOutpath() error {
	inpath := c.inpath

	info, err := os.Stat(inpath)
	if os.IsNotExist(err) {
		return fmt.Errorf("%w: %s", ErrCodegenInpathNotExists, inpath)
	}
	if !info.IsDir() {
		return fmt.Errorf("%w: %s", ErrCodegenInpathNotDir, inpath)
	}

	c.outpath = filepath.Join(inpath, "ginapi")
	_ = os.MkdirAll(c.outpath, os.ModePerm)

	return nil
}

func (c *Codegen) Run() error {
	if err := c.MkOutpath(); err != nil {
		return err
	}
	if err := c.Parser.Parse(); err != nil {
		return err
	}
	if err := c.Generate(); err != nil {
		return err
	}
	return nil
}

func (c *Codegen) Generate() error {
	tmpl, err := template.New("ginapi").Parse(serviceFileTmpl)
	if err != nil {
		return err
	}

	buf := bytes.NewBufferString("")
	if err := tmpl.Execute(buf, c.Parser); err != nil {
		return err
	}

	output, err := format.Source(buf.Bytes())
	if err != nil {
		return err
	}

	fmt.Print(string(output))
	return nil
}
